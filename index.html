<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <!-- Include Bootstrap 5 CSS and JavaScript -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>
</head>
<style>
  .selection_box {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .btn-green {
    background-color: #4caf50;
    border-color: #4caf50;
  }

  .btn-green:hover {
    background-color: #45a049;
    border-color: #45a049;
  }

  .rowData {
    display: flex;
    flex-direction: row;
    gap: 10px;
    width: 100%;
    justify-content: center;
  }

  .searchBar {
    margin-top: 50px;
    margin-bottom: 3rem;
  }

  .graph_div {
    display: flex;
    flex-direction: row;
    margin-top: 40px;
    border: 2px solid black;
    border-radius: 1rem;
    width: 100%;
    height: 550px;
  }

  .error-border {
    border: 2px solid red;
  }


  .alert2 {
    display: none;
  }

  /* slider css  */

  input[type="range"] {
    width: 100%;
  }

  /* csss slider    */


  .wrapper {
    /* width: 400px; */
    background: #fff;
    border-radius: 10px;
    padding: 20px 25px 40px;
    box-shadow: 0 12px 35px rgba(0, 0, 0, 0.1);
  }

  header h2 {
    font-size: 24px;
    font-weight: 600;
  }

  header p {
    margin-top: 5px;
    font-size: 16px;
  }

  .price-input {
    width: 100%;
    display: flex;
    margin: 30px 0 35px;
  }

  .price-input .field {
    display: flex;
    width: 100%;
    height: 45px;
    align-items: center;
  }

  .field input {
    width: 100%;
    height: 100%;
    outline: none;
    font-size: 19px;
    margin-left: 12px;
    border-radius: 5px;
    text-align: center;
    border: 1px solid #999;
    -moz-appearance: textfield;
  }

  input[type="number"]::-webkit-outer-spin-button,
  input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
  }

  .price-input .separator {
    width: 130px;
    display: flex;
    font-size: 19px;
    align-items: center;
    justify-content: center;
  }

  .slider {
    height: 5px;
    position: relative;
    background: #ddd;
    border-radius: 5px;
  }

  .slider .progress {
    height: 100%;
    left: 0%;
    right: 0%;
    position: absolute;
    border-radius: 5px;
    background: #ddd;
  }

  .range-input {
    position: relative;
  }

  .range-input input {
    position: absolute;
    width: 100%;
    height: 5px;
    top: -5px;
    background: none;
    pointer-events: none;
    -webkit-appearance: none;
    -moz-appearance: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    height: 17px;
    width: 17px;
    border-radius: 50%;
    background: green;
    pointer-events: auto;
    -webkit-appearance: none;
    box-shadow: 0 0 6px rgba(0, 0, 0, 0.05);
  }

  input[type="range"]::-moz-range-thumb {
    height: 17px;
    width: 17px;
    border: none;
    border-radius: 50%;
    background: #ddd;
    pointer-events: auto;
    -moz-appearance: none;
    box-shadow: 0 0 6px rgba(0, 0, 0, 0.05);
  }

  /* slider css ended here */

  /* LEGEND CSS STARTED HERE  */
  .legend {
    border: 2px solid black;
    margin: 1rem;
    border-radius: 1rem;
    background-color: white;

  }

  .legenddata {
    font-size: 20px;
    padding-left: 1rem;
  }

  .marked {
    text-decoration: line-through;

    text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);
  }

  .rect {
    display: inline-block;
    width: 20px;
    height: 10px;
    border-radius: 2rem;
    margin-right: 5px;
  }

  .circle {
    display: inline-block;
    width: 14px;
    height: 14px;
    border-radius: 2rem;
    margin-right: 5px;
  }

  ul {
    list-style-type: none;
  }


  /* LEGEND CSS ENDED HERE  */
</style>

<body>
  <div>
    <div class="container searchBar">
      <form class="selection_box flex" id="searchForm">
        <div class="form-row rowData">
          <!-- First Dropdown -->
          <div class="form-group col-md-3">
            <select class="form-select" id="dropdown1">
              <option value="1">Select an option</option>
              <option value="option1">Option 1</option>
              <option value="option2">Option 2</option>
              <option value="option3">Option 3</option>
            </select>
            <!-- Alert message for the first dropdown -->
            <div class="alert-message alert2" style="position: absolute; top: 110px; ">
              <span class="alert alert-danger">Please select an option</span>
            </div>
          </div>

          <!-- Second Dropdown -->
          <div class="form-group col-md-3">
            <select class="form-select" id="dropdown2">
              <option value="2">Select an option</option>
              <option value="option1">Option 1</option>
              <option value="option2">Option 2</option>
              <option value="option3">Option 3</option>
            </select>
            <!-- Alert message for the second dropdown -->
            <div class="alert-message alert2 " style="position: absolute; top: 110px; ">
              <span class="alert alert-danger">Please select an option</span>
            </div>
          </div>

          <!-- Third Dropdown -->
          <div class="form-group col-md-3">
            <select class="form-select" id="dropdown3">
              <option value="3">Select an option</option>
              <option value="option1">Option 1</option>
              <option value="option2">Option 2</option>
              <option value="option3">Option 3</option>
            </select>
            <!-- Alert message for the third dropdown -->
            <div class="alert-message alert2 " style="position: absolute; top: 110px; ">
              <span class="alert alert-danger">Please select an option</span>
            </div>
          </div>
          <!-- button  -->
          <button class="btn btn-success" id="submitButton">
            <i class="bi bi-search"></i> Search
          </button>
        </div>
      </form>

      <div class="graph_div container flex col-12 " id="div2">

        <div class="wrapper col-3">
          <header>
            <h2>links value</h2>
            <p>Use the slider or enter a link range </p>
          </header>
          <div class="price-input">
            <div class="field">
              <span>Min</span>
              <input type="number" class="input-min" value="4.0" step="0.1">
            </div>
            <div class="separator">-</div>
            <div class="field">
              <span>Max</span>
              <input type="number" class="input-max" value="9.0" step="0.1">
            </div>
          </div>
          <div class="slider">
            <div class="progress"></div>
          </div>
          <div class="range-input">
            <input id="min_slider" type="range" class="range-min" min="4.0" max="9.0" step="0.1" value="4.0">
            <input id="max_slider" type="range" class="range-max" min="4.0" max="9.0" step="0.1" value="9.0">
          </div>


          <div class="legend">
            <fieldset class="fieldset">
              <legend class="legenddata">max_phase</legend>
              <ul id="myList"></ul>
              <legend class="legenddata">data_set</legend>
              <ul id="dataset"></ul>
              <legend class="legenddata">child nodes</legend>
              <ul id="child_node"></ul>

            </fieldset>
          </div>

        </div>



        <svg id="forcenetwork" width="100%" style="
                  background-color: white;
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  height:540px;
                " class="col-9"></svg>

      </div>


    </div>
  </div>
  </div>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/d3-force.v2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>


  <script>
    let nodes = [];  // unique nodes   
    let links = [];   // links  from the json files
    let node = [];  // DOM element    
    let link = [];   // DOM ELEMENT 

    let filteredLinks = [];
    let filterNodes = [];
    let listItems = [];  // onclick on the legend 

    let clicked;
    let list_hidden = [];
    let remove_maxPhase = [];

    //  onclick data set 

    let dataSet_link = []
    let clicked2;
    let list_hidden_dataset = [];
    //  onclick child nodes 

    let dataSet_child = []
    let clicked3;
    let list_hidden_childnode = [];


    let minValue;
    let maxValue;


    // fetching the json file  
    async function fetchData() {
      try {
        const response = await fetch("drugdata2.json"); // Replace with the correct JSON file path
        const jsonData = await response.json();

        console.log(jsonData);
        processData(jsonData);
      } catch (error) {
        console.error("Error loading the JSON file:", error);
      }
    }

    fetchData();

    // fetching the data ended here 

    function processData(data) {
      // creating the array of the codes 

      const uniqueProteins = new Set();

      data.forEach((item) => {
        if (!uniqueProteins.has(item.COMPOUND_NAME)) {
          uniqueProteins.add(item.COMPOUND_NAME);

          let calsoleimage;

          if (item.MAX_PHASE === "Approved") {
            calsoleimage = "img3.png"
          }
          else if (item.MAX_PHASE === "PHASE 1") {
            calsoleimage = "img2.png"
          } else if (item.MAX_PHASE === "PHASE 2") {
            calsoleimage = "img4.png"
          } else if (item.MAX_PHASE === "PHASE 3") {
            calsoleimage = "img5.png"
          }
          else if (item.MAX_PHASE === "") {
            calsoleimage = "unknown.png"
          }
          else {
            calsoleimage = "black.png"

          }


          nodes.push({
            id: item.COMPOUND_NAME,
            type: "parentnode",
            image: calsoleimage,
            MAX_PHASE: item.MAX_PHASE,
            flag: true
          });
        }
      });
      data.forEach((item) => {
        if (!uniqueProteins.has(item.CELL_LINE_NAME)) {
          uniqueProteins.add(item.CELL_LINE_NAME);
          nodes.push({
            id: item.CELL_LINE_NAME,
            type: "childnode",
            MAX_PHASE: item.MAX_PHASE,
            oncotree_change: item.ONCOTREE_LINEAGE
          });
        }
      });

      //  creating the links  

      links = data.map((item) => ({
        source: item.COMPOUND_NAME,
        target: item.CELL_LINE_NAME,
        value: item.VALUE,
        max_range_link: item.MAX_PHASE,
        dataset: item.DATASET
      }));

      console.log("nodes", nodes)

      console.log("links", links);


      let tempdata = [];


      data.filter(data => {
        if (!tempdata.includes(data.ONCOTREE_LINEAGE))
          tempdata.push(data.ONCOTREE_LINEAGE)
      })



      console.log(tempdata);
    }




    // custom drag function

    function customDrag(simulation) {
      function dragstarted(event, d) {
        // if (d !== selectedNode) return; // Allow dragging only for the selected node
        if (!event.active) simulation.alphaTarget(0.3).restart();
      }

      function dragged(event, d) {
        // if (d !== selectedNode) return; // Allow dragging only for the selected node
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        // if (d !== selectedNode) return; // Allow dragging only for the selected node
        if (!event.active) simulation.alphaTarget(0);
      }

      return d3
        .drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);
    }


    // custom drag function ended





    //  initialize the graph for the first time  


    function force_network_grapgh() {


      const svg = d3.select("#forcenetwork");

      const g = svg.append("g");

      const simulation = d3
        .forceSimulation(nodes)
        .force(
          "link",
          d3
            .forceLink(links)
            .id((d) => d.id)
            .distance(70)
        )
        .force("charge", d3.forceManyBody().strength(-15))
        .force("x", d3.forceX(500))
        .force("y", d3.forceY(270));

      link = g
        .selectAll(".link ")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "link")
        .style("stroke", "grey")
        .attr("stroke-width", function (d) {

          if (d.value < 5) {
            return 1
          }
          else {

            return d.value - 2;
          }
        });

      node = g
        .selectAll(".node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", "node").call(customDrag(simulation));


      node
        .append("text")
        .text((d) => d.id)
        .attr("dx", 6)
        .attr("dy", "1.5em")
        .attr("font-size", "10px")
        .attr("text-anchor", "middle")
        .style("fill", "black");


      node
        .filter((d) => d.type === "childnode")
        .append("circle")
        .attr("r", 8)
        .attr("fill", function (d) {
          if (d.oncotree_change === "Bone") {
            return "red"
          }
          else if (d.oncotree_change === "Esophagus") {
            return "#33FF57"
          }
          else if (d.oncotree_change === "Lung") {
            return "orange"
          } else if (d.oncotree_change === "Haematopoietic and Lymphoid") {
            return "#33A2FF"
          }
          else {
            return "green"
          }


        })

        .attr("stroke", "#fff")
        .attr("stroke-width", 1.5)


      node
        .filter((d) => d.type === "parentnode")
        .append("image")
        .attr("xlink:href", (d) => d.image)
        .attr("x", -12)
        .attr("y", -8)
        .attr("width", 30);



      simulation.on("tick", () => {
        link
          .attr("x1", (d) => d.source.x)
          .attr("y1", (d) => d.source.y)
          .attr("x2", (d) => d.target.x)
          .attr("y2", (d) => d.target.y);
        node.attr("transform", (d) => `translate(${d.x},${d.y})`);
      });




    }
    // slider range value limitation 


    function range_of_links(min_range, max_range) {


      link.style("display", null);
      node.style("display", null);




      filteredLinks = link.filter(link => {
        // Filter links with a value greater than 5
        return link.value < min_range || link.value > max_range
      });


      filterNodes = node.filter(node => {

        return filteredLinks.data().some(link => (link.target === node || link.source === node));
      });



      // Hide the filtered links

      filteredLinks.style("display", "none");

      // Hide the associated target nodes
      filterNodes.style("display", "none");

      let filterNodes2 = filterNodes.filter(node => {
        // Check if there's at least one link connected to the node that is not in filteredLinks
        const isLinkedToHiddenLink = link.data().some(link => {
          return (link.target === node || link.source === node) && !filteredLinks.data().includes(link);
        });

        return isLinkedToHiddenLink;
      });

      // Reset the display style for the filtered nodes
      filterNodes2.style("display", null);

      //

      node.each(function (d) {

        
        // Check if the node's MAX_PHASE is in the list_hidden
        if (list_hidden.includes(d.MAX_PHASE) && d.type === "parentnode") {
          // Node is in list_hidden, set display to "none"

          d3.select(this).style("display", "none");

        }
      });


      let matchingchild = [];

      let removechild = [];
      const matchinglink = link.filter(function (link) {
        if (list_hidden.includes(link.source.MAX_PHASE)) {
          return link;
        }
      });

      matchinglink.style("display", "none");

      matchinglink.each(function (templink) {
        node.filter(function (childnodes) {

          return templink.target === childnodes;
        }).style("display", "none");
      });

      //    child nodes will be filter here 


      let childnodefilteration = node.filter(function (childNode) {
        if (list_hidden_childnode.includes(childNode.oncotree_change)) {
          return childNode;
        }
      });

      childnodefilteration.style("display", "none");

      let source_node = [];

      let matchinglinkpart = link.filter(function (link) {
        if (list_hidden_childnode.includes(link.target.oncotree_change)) {


          source_node.push(link.source.id)

          return (
            link
          );
        }
      });

      matchinglinkpart.style("display", "none");

      console.log(" source node of the target node", source_node);


      node.each(function (d) {
        // d3.select(this).style("display", "none");   
        if (source_node.includes(d.id)) {


          const connectedLinks = link.filter(
            (link) => link.source.id === d.id
          );

          console.log(connectedLinks);

          const data = connectedLinks.data().map((link) => link.target.oncotree_change);


          const flag2 = data.every((item) => list_hidden_childnode.includes(item));

          if (flag2) {

            console.log("pre")
            d3.select(this).style("display", "none");

            var displayStyle = d3.select(this).style("display");
            console.log("none will be ", displayStyle);
          }
          // else{

          //   d3.select(this).style("display", null);
          // }

        }
      });
    
      node.each(function(d) {
  if (d.type === "parentnode") {
    var nodestyle = d3.select(this).style("display");

    const connectedLinks = link.filter(link => link.source.id === d.id);

    // Array to store styles of connected links
    var linkStyles = [];

    connectedLinks.each(function(link) {
      var linkStyle = d3.select(this).style("display");
      
      linkStyles.push(linkStyle);
    });
console.log(linkStyles) ;
    // Check if every style in the array is "none"
    var allLinksNone = linkStyles.every(style => style === "none");

    if (allLinksNone) {
      // Set node style to "display: none"
      d3.select(this).style("display", "none");
    }
  }
});

    }


    // legenddata
    function legendinfo() {
      const max_phase_categories = [
        { category: "PHASE 1", color: "#000080" },
        { category: "PHASE 2", color: "yellow" },
        { category: "PHASE 3", color: "blue" },
        { category: "Approved", color: "grey" },
        { category: "", color: "#ce7e00" }
      ];



      const data_Set = [
        { category: "GDSC1" },
        { category: "soon" },


      ];

      const data_Set_child = [
        { category: "Bone", color: "red" },
        { category: "Esophagus", color: "#33FF57" },
        { category: "Lung", color: "orange" },
        { category: "Haematopoietic and Lymphoid", color: "#33A2FF" },
      ];


      const ul = d3.select("#myList");
      listItems = ul
        .selectAll("li")
        .data(max_phase_categories)
        .enter()
        .append("li");

      listItems
        .append("div")
        .attr("class", "rect")
        .style("background-color", (d) => {
          for (const categoryObj of max_phase_categories) {
            if (d.category === categoryObj.category) {
              return categoryObj.color;
            }
          }
          return "black";
        });
      listItems.append("span").text((d) => (d.category === "" ? "Unknown" : d.category));

      const ul2 = d3.select("#dataset");
      dataSet_link = ul2
        .selectAll("li")
        .data(data_Set)
        .enter()
        .append("li");

      dataSet_link.append("span").text((d) => d.category);

      const ul3 = d3.select("#child_node");
      dataSet_child = ul3
        .selectAll("li")
        .data(data_Set_child)
        .enter()
        .append("li");
      dataSet_child.append("div")
        .attr("class", "circle")
        .style("background-color", (d) => {
          for (const categoryObj of data_Set_child) {
            if (d.category === categoryObj.category) {
              return categoryObj.color
            }
          }
          return "black"
        })

      dataSet_child.append("span").text((d) => d.category);
    }




    legendinfo();

    function onclickmax_phase(event) {

      d3.select(this)
        .select("span")
        .classed("marked", function () {
          return !d3.select(this).classed("marked");
        });

      clicked = event.target.textContent;

      const index = list_hidden.indexOf(clicked);

      if (clicked === "Unknown") {
        // If 'clicked' is "unknown", check if an empty string ("") is in 'list_hidden'
        const emptyStringIndex = list_hidden.indexOf("");
        if (emptyStringIndex === -1) {
          // If an empty string is not in the array, push it
          list_hidden.push("");
        } else {
          // If an empty string is already in the array, splice it (remove)
          list_hidden.splice(emptyStringIndex, 1);
        }
      } else if (index === -1) {
        // If 'clicked' is not in 'list_hidden', push it
        list_hidden.push(clicked);
      } else {
        // If 'clicked' is already in 'list_hidden', splice it
        list_hidden.splice(index, 1);
      }


      range_of_links(minValue, maxValue);

    }


    function onclick_dataSet(event) {
      d3.select(this)
        .select("span")
        .classed("marked", function () {
          return !d3.select(this).classed("marked");
        });

      clicked2 = event.target.textContent;

      const index = list_hidden_dataset.indexOf(clicked2);


      if (index === -1) {
        list_hidden_dataset.push(clicked2);
      } else {
        list_hidden_dataset.splice(index, 1);
      }


      console.log(list_hidden_dataset);
    }

    function onclick_childnodes(event) {

      d3.select(this)
        .select("span")
        .classed("marked", function () {
          return !d3.select(this).classed("marked");
        });

      clicked3 = event.target.textContent;

      const index = list_hidden_childnode.indexOf(clicked3);


      if (index === -1) {
        list_hidden_childnode.push(clicked3);
      } else {
        list_hidden_childnode.splice(index, 1);
      }



      range_of_links(minValue, maxValue);


    }

    function clearGraph() {
      const svg = d3.select("#forcenetwork");
      svg.selectAll("*").remove();
    }

    // setting the sidler valus 
    const minSlider = document.getElementById("min_slider");
    const maxSlider = document.getElementById("max_slider");

    // Function to log the values of both sliders
    function logSliderValues() {


      minValue = parseFloat(minSlider.value);
      maxValue = parseFloat(maxSlider.value);
      listItems.on("click", onclickmax_phase);

      dataSet_link.on("click", onclick_dataSet);

      dataSet_child.on("click", onclick_childnodes);

      range_of_links(minValue, maxValue);

    }


    // Add onchange event listeners to both sliders
    minSlider.addEventListener("change", logSliderValues);
    maxSlider.addEventListener("change", logSliderValues);




    // slider value ended here 

    document.getElementById("submitButton").addEventListener("click", function (event) {


      // Reset error messages
      document.querySelectorAll(".alert2").forEach(function (alert) {
        alert.style.display = "none";
      });
      document.querySelectorAll(".error-border").forEach(function (element) {
        element.classList.remove("error-border");
      });

      if (
        document.getElementById("dropdown1").value === "" ||
        document.getElementById("dropdown2").value === "" ||
        document.getElementById("dropdown3").value === ""
      ) {
        // Show error messages for the empty dropdowns
        if (document.getElementById("dropdown1").value === "") {
          document.querySelector("#dropdown1 + .alert2").style.display = "block";
          document.getElementById("dropdown1").classList.add("error-border");
        }

        if (document.getElementById("dropdown2").value === "") {
          document.querySelector("#dropdown2 + .alert2").style.display = "block";
          document.getElementById("dropdown2").classList.add("error-border");
        }
        if (document.getElementById("dropdown3").value === "") {
          document.querySelector("#dropdown3 + .alert2").style.display = "block";
          document.getElementById("dropdown3").classList.add("error-border");
        }
        // Prevent form submission
        event.preventDefault();

      }
      else {

        event.preventDefault();
        // loadGraph(4);
        force_network_grapgh(6);

        document.getElementById("dropdown1").value = "";
        document.getElementById("dropdown2").value = "";
        document.getElementById("dropdown3").value = "";

      }



      document.getElementById("dropdown1").addEventListener("change", function () {
        removeError(this);
      });

      document.getElementById("dropdown2").addEventListener("change", function () {
        removeError(this);
      });

      document.getElementById("dropdown3").addEventListener("change", function () {
        removeError(this);
      });

      function removeError(dropdown) {
        // Remove error message and border when a selection is made
        dropdown.nextElementSibling.style.display = "none";
        dropdown.classList.remove("error-border");
      }


    });

    // slider code 

    const rangeInput = document.querySelectorAll(".range-input input");
    const priceInput = document.querySelectorAll(".price-input input");
    const range = document.querySelector(".slider .progress");
    let priceGap = 0.1; // Change the step to 0.1

    priceInput.forEach(input => {
      input.addEventListener("input", (e) => {
        let minPrice = parseFloat(priceInput[0].value);
        let maxPrice = parseFloat(priceInput[1].value);

        if (maxPrice - minPrice >= priceGap && maxPrice <= parseFloat(rangeInput[1].max)) {
          if (e.target.className === "input-min") {
            rangeInput[0].value = minPrice;
            range.style.left = ((minPrice / parseFloat(rangeInput[0].max)) * 100) + "%";
          } else {
            rangeInput[1].value = maxPrice;
            range.style.right = 100 - (maxPrice / parseFloat(rangeInput[1].max)) * 100 + "%";
          }
        }
      });
    });

    rangeInput.forEach(input => {
      input.addEventListener("input", (e) => {
        let minVal = parseFloat(rangeInput[0].value);
        let maxVal = parseFloat(rangeInput[1].value);

        if (maxVal - minVal < priceGap) {
          if (e.target.className === "range-min") {
            rangeInput[0].value = maxVal - priceGap;
          } else {
            rangeInput[1].value = minVal + priceGap;
          }
        } else {
          priceInput[0].value = minVal;
          priceInput[1].value = maxVal;
          range.style.left = ((minVal / parseFloat(rangeInput[0].max)) * 100) + "%";
          range.style.right = 100 - (maxVal / parseFloat(rangeInput[1].max)) * 100 + "%";
        }
      });
    });


  </script>

</body>

</html>